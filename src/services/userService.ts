import crypto from 'crypto';

import bcrypt from 'bcryptjs';
import {inject, injectable} from 'tsyringe';
import mongoose from 'mongoose';

import {IRoleRepository} from '../data/repositories/roleRepository';
import {User} from '../data/schemas';
import {IUserMailerSender} from '../infrastructure/mailer';
import {hashPassword} from '../utils/password';

import {IRatingRepository} from './../data/repositories/ratingRepository';
import {IUserRepository} from './../data/repositories/userRepository';
import {ServiceFailure, ServiceResponse, ServiceResponseStatus} from './types/serviceResponse';
export enum GetUserFailure {
  'UserNotFound' = 'UserNotFound',
}
export enum CreateUserFailure {
  'UserAlreadyExists' = 'UserAlreadyExists',
}
export enum UpdateUserFailure {
  'UserNotFound' = 'UserNotFound',
}
export enum GetAllRoleNamesOfUserFailure {
  'RoleNotFound' = 'RoleNotFound',
}
export enum ChangePasswordFailure {
  IncorrectPassword = 'IncorrectPassword',
}

export interface IUserService {
  createUserWithRoleClient(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>>;
  createUserWithRoleAdmin(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>>;
  getUserDetails(userId: string): Promise<ServiceResponse<User, ServiceFailure<GetUserFailure>>>;
  getAllRoleNamesOfUser(
    userId: string,
  ): Promise<ServiceResponse<string[], ServiceFailure<GetAllRoleNamesOfUserFailure>>>;
  updateUser(
    userId: string,
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>>;
  updateStatusOfUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>>;
  blockUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>>;
  changePassword(
    email: string,
    newPassword: string,
    oldPassword: string,
  ): Promise<ServiceResponse<ServiceFailure<ChangePasswordFailure>>>;
  getAllUsers(): Promise<ServiceResponse>;
  getSeller(userId: string): Promise<ServiceResponse<User, ServiceFailure<GetUserFailure>>>;
  statisticUserCreated(): Promise<ServiceResponse>;
  statisticUserByPost(data: any): Promise<any>;
  statisticBuyer(data: any): Promise<any>;
}

@injectable()
export class UserService implements IUserService {
  constructor(
    @inject('IUserRepository') private userRepository: IUserRepository,
    @inject('IUserMailerSender') private userMailerReceiver: IUserMailerSender,
    @inject('IRoleRepository') private roleRepository: IRoleRepository,
    @inject('IRatingRepository') private ratingRepository: IRatingRepository,
  ) {}

  public async statisticUserByPost(data: any): Promise<any> {
    const userIds = data.map((userData) => userData.user);
    const ids = userIds ? userIds.map(mongoose.Types.ObjectId) : [];
    const dataResult = await this.userRepository.statisticUserByPost(ids);

    const test = [];

    for (let i = 0; i < data.length; i++) {
      for (let d = 0; d < dataResult.length; d++) {
        if (data[d].user === dataResult[i]._id.toHexString()) {
          const a = {
            id: data[d].user,
            name: dataResult[i].name,
            email: dataResult[i].email,
            post: data[d].number_of_posts,
          };

          test.push(a);
        }
      }
    }
    const mothSorted = test.sort((a, b) => (a.post > b.post && 1) || -1);

    return {status: ServiceResponseStatus.Success, result: mothSorted.reverse()};
  }

  public async statisticBuyer(data: any): Promise<any> {
    console.log('data: ', data);
    const userIds = data.map((userData) => userData.payment__buyer);
    const ids = userIds ? userIds.map(mongoose.Types.ObjectId) : [];
    const dataResult = await this.userRepository.statisticUserByPost(ids);

    const test = [];

    for (let i = 0; i < data.length; i++) {
      for (let d = 0; d < dataResult.length; d++) {
        if (data[d].payment__buyer === dataResult[i]._id.toHexString()) {
          const a = {
            id: data[d].payment__buyer,
            name: dataResult[i].name,
            email: dataResult[i].email,
            post: data[d].number_of_orders,
          };

          test.push(a);
        }
      }
    }
    const mothSorted = test.sort((a, b) => (a.post > b.post && 1) || -1);

    return {status: ServiceResponseStatus.Success, result: mothSorted.reverse()};
  }

  public async createUserWithRoleClient(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>> {
    const autoGeneratedPassword = crypto.randomBytes(12).toString('hex');
    const hashedPassword = await hashPassword(autoGeneratedPassword);
    const clientRoleId = (await this.roleRepository.getIdRoleClient())._id;
    const user = {
      ...userData,
      activatedUser: true,
      password: hashedPassword,
      role: [clientRoleId],
      paypalEmail: '',
    };

    const userExisted = await this.userRepository.getUserByEmail(user.email);

    if (userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: CreateUserFailure.UserAlreadyExists},
      };
    }

    const createdUser = await this.userRepository.create(user as User);

    await this.userMailerReceiver.receiveDefaultPassword(user.email, autoGeneratedPassword);

    return {status: ServiceResponseStatus.Success, result: createdUser};
  }

  public async createUserWithRoleAdmin(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>> {
    const autoGeneratedPassword = crypto.randomBytes(12).toString('hex');
    const hashedPassword = await hashPassword(autoGeneratedPassword);
    const adminRoleId = (await this.roleRepository.getIdRoleAdmin())._id;
    const clientRoleId = (await this.roleRepository.getIdRoleClient())._id;
    const user = {
      ...userData,
      activatedUser: true,
      password: hashedPassword,
      role: [clientRoleId, adminRoleId],
      paypalEmail: '',
    };

    const userExisted = await this.userRepository.getUserByEmail(user.email);

    if (userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: CreateUserFailure.UserAlreadyExists},
      };
    }

    const createdUser = await this.userRepository.create(user as User);

    await this.userMailerReceiver.receiveDefaultPassword(user.email, autoGeneratedPassword);

    return {status: ServiceResponseStatus.Success, result: createdUser};
  }

  public async getUserDetails(
    userId: string,
  ): Promise<ServiceResponse<any, ServiceFailure<GetUserFailure>>> {
    const user = await this.userRepository.getUserById(userId);
    const rating = await this.ratingRepository.getRatingOfUser(userId);

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: GetUserFailure.UserNotFound},
      };
    }

    let ratingAverage;

    if (rating.length === 0) {
      ratingAverage = 0;
    } else {
      const ratingOfUser = rating.map((ratingUser) => ratingUser.rating);

      ratingAverage = ratingOfUser.reduce((prev, curr) => prev + curr) / ratingOfUser.length;
    }
    const roleName: any = user['role'];
    const nameRole = roleName.map((i) => i.name);

    delete user.password;
    delete user._id;

    return {
      status: ServiceResponseStatus.Success,
      result: {
        ...user,
        role: nameRole,
        ratingAverage: ratingAverage,
      },
    };
  }

  public async getSeller(
    userId: string,
  ): Promise<ServiceResponse<any, ServiceFailure<GetUserFailure>>> {
    const user = await this.userRepository.getUserById(userId);
    const rating = await this.ratingRepository.getRatingOfUser(userId);

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: GetUserFailure.UserNotFound},
      };
    }
    let ratingAverage;

    if (rating.length === 0) {
      ratingAverage = 0;
    } else {
      const ratingOfUser = rating.map((ratingUser) => ratingUser.rating);

      ratingAverage = ratingOfUser.reduce((prev, curr) => prev + curr) / ratingOfUser.length;
    }

    delete user.password;
    delete user._id;
    delete user.role;
    delete user.email;

    return {
      status: ServiceResponseStatus.Success,
      result: {...user, ratingAverage: ratingAverage},
    };
  }

  public async getAllRoleNamesOfUser(
    userId: string,
  ): Promise<ServiceResponse<string[], ServiceFailure<GetAllRoleNamesOfUserFailure>>> {
    const roles = await this.userRepository.getRoleNameByUserId(userId);

    if (roles.length === 0) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: GetAllRoleNamesOfUserFailure.RoleNotFound},
      };
    }

    return {
      status: ServiceResponseStatus.Success,
      result: roles,
    };
  }

  public async updateUser(
    userId: string,
    userData: User,
  ): Promise<ServiceResponse<any, ServiceFailure<UpdateUserFailure>>> {
    const userExisted = await this.userRepository.getUserById(userId);

    if (!userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: UpdateUserFailure.UserNotFound},
      };
    }

    await this.userRepository.updateUserById(userId, userData);
    const updatedUser = await this.getUserDetails(userId);

    return {
      status: ServiceResponseStatus.Success,
      result: updatedUser,
    };
  }

  public async updateStatusOfUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>> {
    const userExisted = await this.userRepository.getUserById(userId);

    if (!userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: UpdateUserFailure.UserNotFound},
      };
    }

    const updatedUser = await this.userRepository.updateStatusOfUser(userId, status);

    return {
      status: ServiceResponseStatus.Success,
      result: updatedUser,
    };
  }

  public async blockUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>> {
    const userExisted = await this.userRepository.getUserById(userId);

    if (!userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: UpdateUserFailure.UserNotFound},
      };
    }

    const updatedUser = await this.userRepository.updateStatusOfUser(userId, status);

    return {
      status: ServiceResponseStatus.Success,
      result: updatedUser,
    };
  }

  public async changePassword(
    email: string,
    newPassword: string,
    oldPassword: string,
  ): Promise<ServiceResponse<ServiceFailure<ChangePasswordFailure>>> {
    const user = await this.userRepository.getUserByEmail(email);
    const isPasswordMatched = await bcrypt.compare(oldPassword, user.password);

    if (!isPasswordMatched) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: ChangePasswordFailure.IncorrectPassword},
      };
    }

    const hashedPassword = await hashPassword(newPassword);

    await this.userRepository.changePassword(email, hashedPassword);

    return {
      status: ServiceResponseStatus.Success,
    };
  }

  public async getAllUsers(): Promise<ServiceResponse> {
    const users = await this.userRepository.getAllUsers();
    const ratingOfAllUsers = await this.ratingRepository.getRatingOfAllUsers();

    const usersLists = [];

    for (const index in users) {
      let ratingOfUser = 0;
      const roleName: any = users[index]['role'];
      const nameRole = roleName.map((role) => role.name);

      if (index < ratingOfAllUsers.length) {
        for (const i in users) {
          if (users[i]._id.toString() == ratingOfAllUsers[index]._id.toString()) {
            const rating = ratingOfAllUsers[index].ratings.map((temp) => temp.rating);

            ratingOfUser = rating.reduce((prev, curr) => prev + curr) / rating.length;
          }
        }
      }
      const userDetails = {
        userId: users[index]['_id'],
        email: users[index]['email'],
        name: users[index]['name'],
        phone: users[index]['phone'],
        address: users[index]['address'],
        role: nameRole,
        ratingAverage: ratingOfUser,
      };

      usersLists.push(userDetails);
    }

    return {
      result: usersLists,
      status: ServiceResponseStatus.Success,
    };
  }

  private convertNumberToMonthName(month) {
    const monthName = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];

    return monthName[month - 1];
  }

  public async statisticUserCreated(): Promise<ServiceResponse> {
    const userCreated = await this.userRepository.statisticUserCreated();
    const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    const monthInDatabase = [];

    for (let i = 0; i < userCreated.length; i++) {
      monthInDatabase.push(userCreated[i]._id.month);
    }

    const difference = months
      .filter((x) => !monthInDatabase.includes(x))
      .concat(monthInDatabase.filter((x) => !months.includes(x)));

    const countUserCreated = [];

    for (let i = 0; i < monthInDatabase.length; i++) {
      const user = {
        name: userCreated[i]._id.month,
        'Active User': userCreated[i].count,
      };

      countUserCreated.push(user);
    }
    for (let i = 0; i < difference.length; i++) {
      const user = {
        name: difference[i],
        'Active User': 0,
      };

      countUserCreated.push(user);
    }
    const mothSorted = countUserCreated.sort((a, b) => (a.name > b.name && 1) || -1);
    const result = [];

    for (let i = 0; i < mothSorted.length; i++) {
      const user = {
        name: this.convertNumberToMonthName(mothSorted[i].name),
        'Active User': mothSorted[i]['Active User'],
      };

      result.push(user);
    }

    return {
      status: ServiceResponseStatus.Success,
      result: result,
    };
  }
}
