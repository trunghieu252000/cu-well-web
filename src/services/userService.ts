import crypto from 'crypto';

import {inject, injectable} from 'tsyringe';

import {IRoleRepository} from '../data/repositories/roleRepository';
import {User} from '../data/schemas';
import {IUserMailerSender} from '../infrastructure/mailer';
import {hashPassword} from '../utils/password';

import {IUserRepository} from './../data/repositories/userRepository';
import {ServiceFailure, ServiceResponse, ServiceResponseStatus} from './types/serviceResponse';
export enum GetUserFailure {
  'UserNotFound' = 'UserNotFound',
}
export enum CreateUserFailure {
  'UserAlreadyExists' = 'UserAlreadyExists',
}
export enum UpdateUserFailure {
  'UserNotFound' = 'UserNotFound',
}
export enum GetAllRoleNamesOfUserFailure {
  'RoleNotFound' = 'RoleNotFound',
}

export interface IUserService {
  createUserWithRoleClient(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>>;
  getUserDetails(userId: string): Promise<ServiceResponse<User, ServiceFailure<GetUserFailure>>>;
  getAllRoleNamesOfUser(
    userId: string,
  ): Promise<ServiceResponse<string[], ServiceFailure<GetAllRoleNamesOfUserFailure>>>;
  updateUser(
    userId: string,
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>>;
  updateStatusOfUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>>;
}

@injectable()
export class UserService implements IUserService {
  constructor(
    @inject('IUserRepository') private userRepository: IUserRepository,
    @inject('IUserMailerSender') private userMailerReceiver: IUserMailerSender,
    @inject('IRoleRepository') private roleRepository: IRoleRepository,
  ) {}

  public async createUserWithRoleClient(
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<CreateUserFailure>>> {
    const autoGeneratedPassword = crypto.randomBytes(12).toString('hex');
    const hashedPassword = await hashPassword(autoGeneratedPassword);
    const clientRoleId = (await this.roleRepository.getIdRoleClient())._id;
    const user = {
      ...userData,
      activatedUser: true,
      password: hashedPassword,
      ratingAverage: [],
      role: [clientRoleId],
    };

    const userExisted = await this.userRepository.getUserByEmail(user.email);

    if (userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: CreateUserFailure.UserAlreadyExists},
      };
    }

    const createdUser = await this.userRepository.create(user as User);

    await this.userMailerReceiver.receiveDefaultPassword(user.email, autoGeneratedPassword);

    return {status: ServiceResponseStatus.Success, result: createdUser};
  }

  public async getUserDetails(
    userId: string,
  ): Promise<ServiceResponse<any, ServiceFailure<GetUserFailure>>> {
    const user = await this.userRepository.getUserById(userId);
    const roleName: any = user['role'];
    const nameRole = roleName.map((i) => i.name);

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: GetUserFailure.UserNotFound},
      };
    }

    return {
      status: ServiceResponseStatus.Success,
      result: {...user, role: nameRole},
    };
  }

  public async getAllRoleNamesOfUser(
    userId: string,
  ): Promise<ServiceResponse<string[], ServiceFailure<GetAllRoleNamesOfUserFailure>>> {
    const roles = await this.userRepository.getRoleNameByUserId(userId);

    if (roles.length === 0) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: GetAllRoleNamesOfUserFailure.RoleNotFound},
      };
    }

    return {
      status: ServiceResponseStatus.Success,
      result: roles,
    };
  }

  public async updateUser(
    userId: string,
    userData: User,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>> {
    const userExisted = await this.userRepository.getUserById(userId);

    if (userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: UpdateUserFailure.UserNotFound},
      };
    }

    const updatedUser = await this.userRepository.updateUserById(userId, userData);

    return {
      status: ServiceResponseStatus.Success,
      result: updatedUser,
    };
  }

  public async updateStatusOfUser(
    userId: string,
    status: boolean,
  ): Promise<ServiceResponse<User, ServiceFailure<UpdateUserFailure>>> {
    const userExisted = await this.userRepository.getUserById(userId);

    if (userExisted) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {reason: UpdateUserFailure.UserNotFound},
      };
    }

    const updatedUser = await this.userRepository.updateStatusOfUser(userId, status);

    return {
      status: ServiceResponseStatus.Success,
      result: updatedUser,
    };
  }
}
